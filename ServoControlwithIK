#include <Servo.h>
#include <cmath>

#define NUM_SERVOS 5 

const long IK_INTERVAL = 5000;

unsigned long previousMillis = 0; 
int step = 0; 


const uint8_t servoPins[NUM_SERVOS] = {19, 18, 5, 17, 16}; 
Servo myServos[NUM_SERVOS];
uint8_t currentAngles[NUM_SERVOS] = {90, 90, 90, 90, 90}; //initial position


const double L1 = 121.0; // Link 
const double L2 = 122.0; 
const double L3 = 95.0;  

//inverse kinematics
struct ThreeDofResult {
    double theta1a, theta2a, theta3a; 
    double theta1b, theta2b, theta3b; 
    bool valid;
};

struct InverseKinematicsResult {
    double deg1, deg2, deg3, deg4;
    bool valid;
};

ThreeDofResult three_dof(double x, double y, double l1, double l2, double l3, double gamma);
InverseKinematicsResult inverse_kinematics(double x, double y, double z, double phi_deg, double l1, double l2, double l3);
void moveArmJointsArray(const uint8_t angles[]);

void setup() {
  Serial.begin(9600);
  for (int i = 0; i < NUM_SERVOS; i++) {
    myServos[i].attach(servoPins[i]);
    myServos[i].write(currentAngles[i]); 
  }
  delay(1000);
  Serial.println("Ready");
}

void loop() {
  unsigned long currentMillis = millis();

  if (currentMillis - previousMillis >= IK_INTERVAL) {
    previousMillis = currentMillis; // Reset timer

    double target_X, target_Z, target_Phi;
    
    switch (step) {
      case 0: // if target low
        target_X = 25.0; target_Z = 10.0; target_Phi = 0.0;
        myServos[4].write(30); // close
        Serial.println("\n-- Pindah ke Titik 1 -- X=25, Z=10, Phi=0");
        step = 1;
        break;
      case 1: // if target high
        target_X = 15.0; target_Z = 20.0; target_Phi = 90.0;
        myServos[4].write(150); // open
        Serial.println("\n-- Pindah ke Titik 2 -- X=15, Z=20, Phi=90");
        step = 2;
        break;
      default: // neutral
        target_X = 18.0; target_Z = 5.0; target_Phi = 45.0;
        myServos[4].write(90); 
        Serial.println("\n-- Kembali ke Titik Awal -- X=18, Z=5, Phi=45");
        step = 0; 
        break;
    }

    double target_Y = 0.0; 
    
    InverseKinematicsResult res = inverse_kinematics(
      target_X, target_Y, target_Z, target_Phi, 
      L1, L2, L3
    );

    if (res.valid) {
      //convert and constrain
      currentAngles[0] = (uint8_t)constrain(round(res.deg1), 0, 180); // Base
      currentAngles[1] = (uint8_t)constrain(round(res.deg2), 0, 180); // Shoulder
      currentAngles[2] = (uint8_t)constrain(round(res.deg3), 0, 180); // Elbow
      currentAngles[3] = (uint8_t)constrain(round(res.deg4), 0, 180); // Wrist
        
      moveArmJointsArray(currentAngles); 

      Serial.print("IK Sukses. Sudut: Base="); Serial.print(currentAngles[0]);
      Serial.print(", Sh="); Serial.print(currentAngles[1]);
      Serial.print(", El="); Serial.print(currentAngles[2]);
      Serial.print(", Wr="); Serial.println(currentAngles[3]);

    } else {
      Serial.print("Target Gagal: X:"); Serial.print(target_X); 
      Serial.print(", Z:"); Serial.print(target_Z); 
      Serial.println(" di luar jangkauan.");
    }
  }
}

void moveArmJointsArray(const uint8_t angles[]) {
  for (int i = 0; i < 4; i++) {
    uint8_t constrainedAngle = constrain(angles[i], 0, 180); 
    myServos[i].write(constrainedAngle);
  }
}

// IK 2D PLANAR FUNCTION 
ThreeDofResult three_dof(double x, double y, double l1, double l2, double l3, double gamma) {
    ThreeDofResult result = {0, 0, 0, 0, 0, 0, false};
    
    double x3 = x - l3 * cos(gamma); 
    double y3 = y - l3 * sin(gamma);
    
    //Reachability check
    double d = sqrt(x3 * x3 + y3 * y3);
    if (d > l1 + l2 || d < fabs(l1 - l2)) {
        return result; // Di luar jangkauan
    }
    
    double cos_theta2 = (x3 * x3 + y3 * y3 - l1 * l1 - l2 * l2) / (2 * l1 * l2);
    if (cos_theta2 > 1.0) cos_theta2 = 1.0;
    if (cos_theta2 < -1.0) cos_theta2 = -1.0;
    
    double theta2a = acos(cos_theta2); 
    double theta2b = -theta2a;        
  
    double theta1a = atan2(y3, x3) - atan2(l2 * sin(theta2a), l1 + l2 * cos(theta2a));
    double theta1b = atan2(y3, x3) - atan2(l2 * sin(theta2b), l1 + l2 * cos(theta2b));
    
    double theta3a = gamma - theta1a - theta2a;
    double theta3b = gamma - theta1b - theta2b;
    
    result.theta1a = theta1a * 180.0 / M_PI;
    result.theta2a = theta2a * 180.0 / M_PI;
    result.theta3a = theta3a * 180.0 / M_PI;
    result.theta1b = theta1b * 180.0 / M_PI;
    result.theta2b = theta2b * 180.0 / M_PI;
    result.theta3b = theta3b * 180.0 / M_PI;
    result.valid = true;
    
    return result;
}

//IK 4DOF FUNCTION
InverseKinematicsResult inverse_kinematics(double x, double y, double z, double phi_deg, double l1, double l2, double l3) {
    InverseKinematicsResult result = {0, 0, 0, 0, false};
    
    double phi_rad = phi_deg * M_PI / 180.0;
    
    double r = sqrt(x * x + y * y);
    // Sudut Base (Theta1)
    double deg1 = atan2(y, x) * 180.0 / M_PI;

    ThreeDofResult three_result = three_dof(r, z, l1, l2, l3, phi_rad);
    
    if (!three_result.valid) {
        return result;
    }
    
    result.deg1 = deg1;
    result.deg2 = three_result.theta1b; 
    result.deg3 = three_result.theta2b; 
    result.deg4 = three_result.theta3b; 
    
    result.valid = true;
    return result;
}
